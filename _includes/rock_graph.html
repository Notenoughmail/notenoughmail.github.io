<script>
    function parse() {
        query = document.location.href.split("?")[1];
        if (query == undefined) {
            window.open(document.location.href + "?{% include rock_default.txt %}", "_self");
        } else {
            try {
                properties = query.split("&");
                version = findStartingInArray(properties, "version=").split("=")[1];
                if (version == "1.20.1" || version == "1.21.1") {
                    ocean = decompose(findStartingInArray(properties, "ocean_type="));
                    land = decompose(findStartingInArray(properties, "land_type="));
                    uplift = decompose(findStartingInArray(properties, "uplift_type="));
                    volcanic = decompose(findStartingInArray(properties, "volcanic_type="));
                    layers = decompose(findStartingInArray(properties, "layers="));
                    bottom = decompose(findStartingInArray(properties, "bottom_type="));
                    let definition = `flowchart TD\nsubgraph types [ ];\nocean_type[Ocean Floor]\nland_type[Land]\nuplift_type[Uplift]\nvolcanic_type[Volcanic]\nend\nsubgraph bottoms [ ];\nbottom[${toTitleCase(bottom.join(", "))}]\nend\n`;
                    let allMap = {};
                    for (let i in layers) {
                        let layer = layers[i];
                        allMap[layer] = reverseConsolidate(decompose(findStartingInArray(properties, `${layer}=`)));
                    }
                    let seenLayers = [];
                    seenLayers.push("bottom");
                    let accept = r => definition = `${definition}${r}\n`;
                    fillLayers(seenLayers, allMap, accept);
                    fillLayerType(seenLayers, allMap, ocean, "ocean_type", accept);
                    fillLayerType(seenLayers, allMap, land, "land_type", accept);
                    fillLayerType(seenLayers, allMap, uplift, "uplift_type", accept);
                    fillLayerType(seenLayers, allMap, volcanic, "volcanic_type", accept);
                    let graph = document.createElement("pre");
                    graph.className = "mermaid";
                    graph.id = "mermaid_graph";
                    graph.textContent = definition;
                    let existingGraph = document.querySelector("#mermaid_graph");
                    if (existingGraph == null) {
                        window.alert("Could not find graph in page!");
                    } else {
                        existingGraph.replaceWith(graph);
                    }
                } else {
                    window.alert("Version not supported: " + version);
                }
            } catch (exception) {
                window.alert("Invalid query!\n\nQuery: " + query + "\n\n" + exception);
                console.error(exception);
            }
        }
    }
    function fillLayerType(seenLayers, allMap, def, name, accept) {
        for (let i in def) {
            let layer = def[i];
            if (seenLayers.includes(layer)) {
                accept(`${name} -.-> ${layer}`);
            } else {
                let mapping = allMap[layer];
                for (let toLayer in mapping) {
                    let rocks = mapping[toLayer];
                    accept(path(name, rocks, toLayer));
                }
            }
        }
    }
    function fillLayers(seenLayers, allMap, accept) {
        for (let layer in allMap) {
            let mapping = allMap[layer];
            for (let toLayer in mapping) {
                let rocks = mapping[toLayer];
                if (!seenLayers.includes(toLayer)) {
                    accept(`${toLayer}@{ shape: start }`);
                    seenLayers.push(toLayer);
                }
            }
        }
        for (let i in seenLayers) {
            let layer = seenLayers[i];
            let mapping = allMap[layer];
            for (let toLayer in mapping) {
                let rocks = mapping[toLayer];
                accept(path(layer, rocks, toLayer));
            }
        }
    }
    function path(from, rocks, to) {
        return `${from} -->|${toTitleCase(rocks.join(", "))}| ${to}`;
    }
    function decompose(property) {
        values = property.split("=")[1];
        values = values.substring(1, values.length - 1);
        return values.split(";");
    }
    function reverseConsolidate(mapLikeArray) {
        const out = {};
        for (let i in mapLikeArray) {
            let kv = mapLikeArray[i].split("~");
            if (out[kv[1]] == undefined) {
                out[kv[1]] = [];
            }
            out[kv[1]].push(kv[0]);
        }
        return out;
    }
    function toTitleCase(str) {
        let split = str.split(/[\s.:_-]/);
        let out = "";
        for (let i in split) {
            if (split[i].length != 0) {
                let text = capitalizeFirst(split[i]);
                if (out.length == 0) {
                    out = text;
                } else {
                    out = out + " " + text;
                }
            }
        }
        return out;
    }
    function capitalizeFirst(str) {
        return str.charAt(0).toUpperCase() + str.substring(1).toLowerCase();
    }
    function findStartingInArray(array, start) {
        for (let i in array) {
            if (array[i].startsWith(start)) {
                return array[i];
            }
        }
        return undefined;
    }
</script>